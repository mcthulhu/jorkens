<script>
      function dropHandler(event) {
        console.log('File(s) dropped');
        event.preventDefault();
		if (event.dataTransfer.items) {
          if (event.dataTransfer.items[0].kind === 'file') {
            var file = event.dataTransfer.items[0].getAsFile();
				console.log(file.type);
                if (file.type === 'application/epub+zip') {
                  var reader = new FileReader();
                    reader.onload = e => {
                      console.log(e.target.result);
                    };

                    reader.readAsText(file);
                  }
            }
        }
      }
      </script>
	  
	  
 function loadInitialBook() {
    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var url = params && params.get("url") && decodeURIComponent(params.get("url"));
    var currentSectionIndex = (params && params.get("loc")) ? params.get("loc") : undefined;

    // Load the opf
    //var book = ePub(url || "https://s3.amazonaws.com/moby-dick/moby-dick.epub");
	var book = ePub(url || "moby-dick.epub");
    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600,
      spread: "always"
    });

    rendition.display(currentSectionIndex);

    book.ready.then(() => {

      var next = document.getElementById("next");

      next.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        e.preventDefault();
      }, false);

      var prev = document.getElementById("prev");
      prev.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        e.preventDefault();
      }, false);

      var keyListener = function(e){

        // Left Key
        if ((e.keyCode || e.which) == 37) {
          book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        }

        // Right Key
        if ((e.keyCode || e.which) == 39) {
          book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        }

      };

      rendition.on("keyup", keyListener);
      document.addEventListener("keyup", keyListener, false);

    })

    var title = document.getElementById("title");

    rendition.on("rendered", function(section){
      var current = book.navigation && book.navigation.get(section.href);

      if (current) {
        var $select = document.getElementById("toc");
        var $selected = $select.querySelector("option[selected]");
        if ($selected) {
          $selected.removeAttribute("selected");
        }

        var $options = $select.querySelectorAll("option");
        for (var i = 0; i < $options.length; ++i) {
          let selected = $options[i].getAttribute("ref") === current.href;
          if (selected) {
            $options[i].setAttribute("selected", "");
          }
        }
      }

    });

    rendition.on("relocated", function(location){
      console.log(location);

      var next = book.package.metadata.direction === "rtl" ?  document.getElementById("prev") : document.getElementById("next");
      var prev = book.package.metadata.direction === "rtl" ?  document.getElementById("next") : document.getElementById("prev");

      if (location.atEnd) {
        next.style.visibility = "hidden";
      } else {
        next.style.visibility = "visible";
      }

      if (location.atStart) {
        prev.style.visibility = "hidden";
      } else {
        prev.style.visibility = "visible";
      }

    });

    rendition.on("layout", function(layout) {
      let viewer = document.getElementById("viewer");

      if (layout.spread) {
        viewer.classList.remove('single');
      } else {
        viewer.classList.add('single');
      }
    });

    window.addEventListener("unload", function () {
      console.log("unloading");
      this.book.destroy();
    });

    book.loaded.navigation.then(function(toc){
			var $select = document.getElementById("toc"),
					docfrag = document.createDocumentFragment();

			toc.forEach(function(chapter) {
				var option = document.createElement("option");
				option.textContent = chapter.label;
				option.setAttribute("ref", chapter.href);

				docfrag.appendChild(option);
			});

			$select.appendChild(docfrag);

			$select.onchange = function(){
					var index = $select.selectedIndex,
							url = $select.options[index].getAttribute("ref");
					rendition.display(url);
					return false;
			};

		});
}
  </script>
  <script>
  
  
  Listing 4.5. Whitelisting specific file types: ./app/main.js

const getFileFromUser = () => {
  const files = dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [                                                     1
      { name: 'Text Files', extensions: ['txt'] },
      { name: 'Markdown Files', extensions: ['md', 'markdown'] }
    ]
  });

  if (!files) { console.log("no file found"); return; }

  const file = files[0];
  const content = fs.readFileSync(file).toString();

  console.log(content);
};


With these new additions, the user can now click the Open File button, select a file using a native file dialog box, and render the contents in the UI. We’ve successfully implemented the feature that we set out to implement at the beginning of the chapter. The code for our main and renderer processes should look something like the following two listings.
Listing 4.16. Open File functionality implemented in the main process: ./app/main.js

const { app, BrowserWindow, dialog } = require('electron');
const fs = require('fs');

let mainWindow = null;

app.on('ready', () => {
  mainWindow = new BrowserWindow({ show: false });

  mainWindow.loadFile('index.html');

  mainWindow.once('ready-to-show', () => {
    mainWindow.show();
  });

  mainWindow.on('closed', () => {
    mainWindow = null;
  });
});

const getFileFromUser = exports.getFileFromUser = () => {
  const files = dialog.showOpenDialog(mainWindow, {
    properties: ['openFile'],
    filters: [
      { name: 'Text Files', extensions: ['txt'] },
      { name: 'Markdown Files', extensions: ['md', 'markdown'] }
    ]
  });

  if (files) { openFile(files[0]) }
};

const openFile = (file) => {
  const content = fs.readFileSync(file).toString();
  mainWindow.webContents.send('file-opened', file, content);
};

Listing 4.17. Open File functionality implemented: ./app/renderer.js

const { remote, ipcRenderer } = require('electron');
const mainProcess = remote.require('./main.js');

const marked = require('marked');

const markdownView = document.querySelector('#markdown');
const htmlView = document.querySelector('#html');
const newFileButton = document.querySelector('#new-file');
const openFileButton = document.querySelector('#open-file');
const saveMarkdownButton = document.querySelector('#save-markdown');
const revertButton = document.querySelector('#revert');
const saveHtmlButton = document.querySelector('#save-html');
const showFileButton = document.querySelector('#show-file');
const openInDefaultButton = document.querySelector('#open-in-default');

const renderMarkdownToHtml = (markdown) => {
  htmlView.innerHTML = marked(markdown, { sanitize: true });
};

markdownView.addEventListener('keyup', (event) => {
  const currentContent = event.target.value;
  renderMarkdownToHtml(currentContent);
});

openFileButton.addEventListener('click', () => {
  mainProcess.getFileFromUser();
});

ipcRenderer.on('file-opened', (event, file, content) => {
  markdownView.value = content;
  renderMarkdownToHtml(content);
});

 function checkIfBookStartOrEnd() {
   let renderer = book.renderer;
   let spinePos = renderer.currentChapter.spinePos;
   let spineLength = book.spine.length;
   let chapterPos = renderer.chapterPos;
   let chapterLength = renderer.currentChapter.pages

    if ((spinePos === 0) && (chapterPos === 1)) {
        // On first page - you can hide the previous page button.
    } else if ((spinePos === spineLength - 1) && (chapterPos === chapterLength)) {
        // On last page - you can hide the next page button.
    }
}

book.on("renderer:locationChanged", checkIfBookStartOrEnd);

When I try to use the reader.adjustFontSize function, it throws an error because there is no this.book.setStyle in epub.js. Can you point me in the right direction for changing the font size? @fchasen
@ledandmetallica
Author
ledandmetallica commented on May 15, 2018 •

Ok I figured it out... change lines 3351 through 3368 of reader.js to this:

       if(MOD && e.keyCode == PLUS) {
		e.preventDefault();
		this.settings.styles.fontSize = (fontSize + interval) + "%";
		this.rendition.themes.fontSize((fontSize + interval) + "%");
	}

	if(MOD && e.keyCode == MINUS){

		e.preventDefault();
		this.settings.styles.fontSize = (fontSize - interval) + "%";
		this.rendition.themes.fontSize((fontSize - interval) + "%");
	}

	if(MOD && e.keyCode == ZERO){
		e.preventDefault();
		this.settings.styles.fontSize = "100%";
		this.rendition.themes.fontSize("100%");
	}


First install electron-rebuild:

npm install --save-dev electron-rebuild

Then install sqlite3 module:

npm install sqlite3 --save

Next rebuild sqlite3 for Electron with:

./node_modules/.bin/electron-rebuild  -f -w sqlite3

If the process goes without problems you should be good to go.
Using SQLite3

Now lets see a small example of how to use SQLite3, first we need to import sqlite3 module:

const sqlite3 = require('sqlite3');

Then create a Database object to connect to an in-memory database:

var db = new sqlite3.Database(':memory:');

You can also use a file based database by specifying the path to a file instead:

var db = new sqlite3.Database('/path/to/database/file.db');

Next lets create a table and insert some values ,query them then print the result on the console:

db.serialize(function () {
  db.run("CREATE TABLE Products (name, barcode, quantity)");

  db.run("INSERT INTO Products VALUES (?, ?, ?)", ['product001', 'xxxxx', 20]);
  db.run("INSERT INTO Products VALUES (?, ?, ?)", ['product002', 'xxxxx', 40]);
  db.run("INSERT INTO Products VALUES (?, ?, ?)", ['product003', 'xxxxx', 60]);

  db.each("SELECT * FROM Products", function (err, row) {
    console.log(row);
  });
});

Finally, after finsihing with our database we can close it with:

db.close();


const sqlite3 = require('sqlite3').verbose();
 
// open the database
let db = new sqlite3.Database('./db/chinook.db', sqlite3.OPEN_READWRITE, (err) => {
  if (err) {
    console.error(err.message);
  }
  console.log('Connected to the chinook database.');
});
 
db.serialize(() => {
  db.each(`SELECT PlaylistId as id,
                  Name as name
           FROM playlists`, (err, row) => {
    if (err) {
      console.error(err.message);
    }
    console.log(row.id + "\t" + row.name);
  });
});
 
db.close((err) => {
  if (err) {
    console.error(err.message);
  }
  console.log('Close the database connection.');
});

Querying all rows with all() method

The all() method allows you to execute an SQL query with specified parameters and call a callback to access the rows in the result set.

The following is the signature of the all() method:
db.all(sql,params,(err, rows ) => {
    // process rows here    
});
1
2
3
	
db.all(sql,params,(err, rows ) => {
    // process rows here    
});

The err argument stores the error detail in case there was an error occurred during the execution of the query. Otherwise, the err will be null. If the query is executed successfully, the rows argument contains the result set of the query.

Because the all() method retrieves all rows and places them in the memory, therefore, for the large result set, you should use the each() method.

The following example illustrates how to query data from the playlists table in the sample database using the all() method:
const sqlite3 = require('sqlite3').verbose();

// open the database
let db = new sqlite3.Database('./db/chinook.db');

let sql = `SELECT DISTINCT Name name FROM playlists
           ORDER BY name`;

db.all(sql, [], (err, rows) => {
  if (err) {
    throw err;
  }
  rows.forEach((row) => {
    console.log(row.name);
  });
});

// close the database connection
db.close();
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
	
const sqlite3 = require('sqlite3').verbose();
 
// open the database
let db = new sqlite3.Database('./db/chinook.db');
 
let sql = `SELECT DISTINCT Name name FROM playlists
           ORDER BY name`;
 
db.all(sql, [], (err, rows) => {
  if (err) {
    throw err;
  }
  rows.forEach((row) => {
    console.log(row.name);
  });
});
 
// close the database connection
db.close();

Let’s run the program.
>node all.js
90's Music
Audiobooks
Brazilian Music
Classical
Classical 101 - Deep Cuts
Classical 101 - Next Steps
Classical 101 - The Basics
Grunge
Heavy Metal Classic
Movies
Music
Music Videos
On-The-Go 1
TV Shows
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
	
>node all.js
90's Music
Audiobooks
Brazilian Music
Classical
Classical 101 - Deep Cuts
Classical 101 - Next Steps
Classical 101 - The Basics
Grunge
Heavy Metal Classic
Movies
Music
Music Videos
On-The-Go 1
TV Shows

The output shows all playlists as expected.
Query the first row in the result set

When you know that the result set contains zero or one row e.g., querying a row based on the primary key or querying with only one aggregate function such as count, sum, max, min, etc., you can use the get() method of Database object.
db.get(sql, params, (err, row) => {
    // process the row here 
});
1
2
3
	
db.get(sql, params, (err, row) => {
    // process the row here 
});

The get() method executes an SQL query and calls the callback function on the first result row. In case the result set is empty, the row argument is undefined.

The following get.js program demonstrates how to query a playlist by its id:
const sqlite3 = require('sqlite3').verbose();

// open the database
let db = new sqlite3.Database('./db/chinook.db');

let sql = `SELECT PlaylistId id,
                  Name name
           FROM playlists
           WHERE PlaylistId  = ?`;
let playlistId = 1;

// first row only
db.get(sql, [playlistId], (err, row) => {
  if (err) {
    return console.error(err.message);
  }
  return row
    ? console.log(row.id, row.name)
    : console.log(`No playlist found with the id ${playlistId}`);

});

// close the database connection
db.close();
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
	
const sqlite3 = require('sqlite3').verbose();
 
// open the database
let db = new sqlite3.Database('./db/chinook.db');
 
let sql = `SELECT PlaylistId id,
                  Name name
           FROM playlists
           WHERE PlaylistId  = ?`;
let playlistId = 1;
 
// first row only
db.get(sql, [playlistId], (err, row) => {
  if (err) {
    return console.error(err.message);
  }
  return row
    ? console.log(row.id, row.name)
    : console.log(`No playlist found with the id ${playlistId}`);
 
});
 
// close the database connection
db.close();

Let’s run the get.js program.
>node get.js
1 'Music'
1
2
	
>node get.js
1 'Music'

The output shows the Music playlist which is correct.

If you change the playlistId to 0 and execute the get.js program again:
>node get.js
No playlist found with the id 0
1
2
	
>node get.js
No playlist found with the id 0

It showed that no playlist found with id 0 as expected.
Query rows with each() method

The each() method executes an SQL query with specified parameters and calls a callback for every row in the result set.

The following illustrates the signature of the each() method:
db.each(sql,params, (err, result) => {
   // process each row here
});
1
2
3
	
db.each(sql,params, (err, result) => {
   // process each row here
});

If the result set is empty, the callback is never called. In case there is an error, the err parameter contains the detailed information.

The following each.js program illustrates how to use the each() method to query customer’s data from the customers table.
const sqlite3 = require('sqlite3').verbose();

// open the database
let db = new sqlite3.Database('../db/chinook.db');

let sql = `SELECT FirstName firstName,
                  LastName lastName,
                  Email email
            FROM customers
            WHERE Country = ?
            ORDER BY FirstName`;

db.each(sql, ['USA'], (err, row) => {
  if (err) {
    throw err;
  }
  console.log(`${row.firstName} ${row.lastName} - ${row.email}`);
});

// close the database connection
db.close();
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
	
const sqlite3 = require('sqlite3').verbose();
 
// open the database
let db = new sqlite3.Database('../db/chinook.db');
 
let sql = `SELECT FirstName firstName,
                  LastName lastName,
                  Email email
            FROM customers
            WHERE Country = ?
            ORDER BY FirstName`;
 
db.each(sql, ['USA'], (err, row) => {
  if (err) {
    throw err;
  }
  console.log(`${row.firstName} ${row.lastName} - ${row.email}`);
});
 
// close the database connection
db.close();

Let’s run the each.js program:
>node each.js
Dan Miller - dmiller@comcast.com
Frank Harris - fharris@google.com
Frank Ralston - fralston@gmail.com
Heather Leacock - hleacock@gmail.com
Jack Smith - jacksmith@microsoft.com
John Gordon - johngordon22@yahoo.com
Julia Barnett - jubarnett@gmail.com
Kathy Chase - kachase@hotmail.com
Michelle Brooks - michelleb@aol.com
Patrick Gray - patrick.gray@aol.com
Richard Cunningham - ricunningham@hotmail.com
Tim Goyer - tgoyer@apple.com
Victor Stevens - vstevens@yahoo.com
1
2
3
4
5
6
7
8
9
10
11
12
13
14
	
>node each.js
Dan Miller - dmiller@comcast.com
Frank Harris - fharris@google.com
Frank Ralston - fralston@gmail.com
Heather Leacock - hleacock@gmail.com
Jack Smith - jacksmith@microsoft.com
John Gordon - johngordon22@yahoo.com
Julia Barnett - jubarnett@gmail.com
Kathy Chase - kachase@hotmail.com
Michelle Brooks - michelleb@aol.com
Patrick Gray - patrick.gray@aol.com
Richard Cunningham - ricunningham@hotmail.com
Tim Goyer - tgoyer@apple.com
Victor Stevens - vstevens@yahoo.com

As you see, the callback function was called for each row to print out the customer’s information.

In this tutorial, you have learned how to use various methods of the Database object to query data from the SQLite database.

The sqlite3 module provides you with two methods for controlling the execution flow of statements. The serialize() method allows you to execute statements in serialized mode, while the parallelize() method executes the statements in parallel.

Let’s look into each method in detail to understand how it works.
Executing statement in serialized mode with Database.serialize

The serialize() method puts the execution mode into serialized mode. It means that only one statement can execute at a time. Other statements will wait in a queue until all the previous statements are executed.

After the serialize() method returns, the execution mode is set to the original mode again.

It’s safe to nest the serialize() method as follows:
db.serialize(() => {
  // queries will execute in serialized mode
  db.serialize(() => {
    // queries will execute in serialized mode
  });
  // queries will execute in serialized mode
});
1
2
3
4
5
6
7
	
db.serialize(() => {
  // queries will execute in serialized mode
  db.serialize(() => {
    // queries will execute in serialized mode
  });
  // queries will execute in serialized mode
});

Suppose, you want to execute the following three statements in sequence:

    Create a new table.
    Insert data into the table.
    Query data from the table.

To do this, you place these statements in the serialize() method as follows:
const sqlite3 = require('sqlite3').verbose();

// open the database connection
let db = new sqlite3.Database(':memory:', (err) => {
  if (err) {
    console.error(err.message);
  }
});

db.serialize(() => {
  // Queries scheduled here will be serialized.
  db.run('CREATE TABLE greetings(message text)')
    .run(`INSERT INTO greetings(message)
          VALUES('Hi'),
                ('Hello'),
                ('Welcome')`)
    .each(`SELECT message FROM greetings`, (err, row) => {
      if (err){
        throw err;
      }
      console.log(row.message);
    });
});

// close the database connection
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
});
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
	
const sqlite3 = require('sqlite3').verbose();
 
// open the database connection
let db = new sqlite3.Database(':memory:', (err) => {
  if (err) {
    console.error(err.message);
  }
});
 
db.serialize(() => {
  // Queries scheduled here will be serialized.
  db.run('CREATE TABLE greetings(message text)')
    .run(`INSERT INTO greetings(message)
          VALUES('Hi'),
                ('Hello'),
                ('Welcome')`)
    .each(`SELECT message FROM greetings`, (err, row) => {
      if (err){
        throw err;
      }
      console.log(row.message);
    });
});
 
// close the database connection
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
});

Because the run() method returns a Database object so that we could chain the method calls.

Let’s run the program to see how it works.
> node serialize.js
Hi
Hello
Welcome
1
2
3
4
	
> node serialize.js
Hi
Hello
Welcome

It works as expected.

Notice that if you don’t place three statements in the serialize() method, all the three statements may execute in parallel which would cause an error.
Executing statements in parallel with Database.parallelize

If you want the scheduled queries to execute in parallel, you place them in the parallelize() method.

Similar to the serialize() method, it is safe to nest the parallelize() method as follows:
db.parallelize(() => {
  // queries will execute in parallel mode
  db.parallelize(() => {
    // queries will execute in parallel mode
  });
  // queries will execute in parallel mode
});
1
2
3
4
5
6
7
	
db.parallelize(() => {
  // queries will execute in parallel mode
  db.parallelize(() => {
    // queries will execute in parallel mode
  });
  // queries will execute in parallel mode
});

For the demonstration, we will create a new function that calculates the sum of two numbers using SQLite database and place the function calls in the parallelize() method as shown in the following example:
const sqlite3 = require('sqlite3').verbose();

// open a database connection
let db = new sqlite3.Database(':memory:', (err) => {
  if (err) {
    console.error(err.message);
  }
});

db.parallelize(() => {
  dbSum(1, 1, db);
  dbSum(2, 2, db);
  dbSum(3, 3, db);
  dbSum(4, 4, db);
  dbSum(5, 5, db);
});

// close the database connection
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
});

function dbSum(a, b, db) {
  db.get('SELECT (? + ?) sum', [a, b], (err, row) => {
    if (err) {
      console.error(err.message);
    }
    console.log(`The sum of ${a} and ${b} is ${row.sum}`);
  });
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
	
const sqlite3 = require('sqlite3').verbose();
 
// open a database connection
let db = new sqlite3.Database(':memory:', (err) => {
  if (err) {
    console.error(err.message);
  }
});
 
db.parallelize(() => {
  dbSum(1, 1, db);
  dbSum(2, 2, db);
  dbSum(3, 3, db);
  dbSum(4, 4, db);
  dbSum(5, 5, db);
});
 
// close the database connection
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
});
 
function dbSum(a, b, db) {
  db.get('SELECT (? + ?) sum', [a, b], (err, row) => {
    if (err) {
      console.error(err.message);
    }
    console.log(`The sum of ${a} and ${b} is ${row.sum}`);
  });
}

Let’s run the parallelize.js program.
>node parallelize.js
The sum of 5 and 5 is 10
The sum of 1 and 1 is 2
The sum of 4 and 4 is 8
The sum of 3 and 3 is 6
The sum of 2 and 2 is 4
1
2
3
4
5
6
	
>node parallelize.js
The sum of 5 and 5 is 10
The sum of 1 and 1 is 2
The sum of 4 and 4 is 8
The sum of 3 and 3 is 6
The sum of 2 and 2 is 4

As you see in the output, the order of execution is not the same as it was called in the program.

Notice that the statements execute in parallel, therefore, each time you run the program, the order of execution may be different.

In this tutorial, you have learned how to control the execution flow of the statements.

Summary: in this tutorial, you will learn how to insert one or more row into an SQLite table from a Node.js application.

To insert data into an SQLite table from a Node.js application, you follow these steps:

    Open a database connection.
    Execute an INSERT statement.
    Close the database connection.

For the demonstration, we will create a new database named sample.db in the db folder.

When you open a database connection in the default mode, the database is created if it does not exist.
let db = new sqlite3.Database('./db/sample.db');
1
	
let db = new sqlite3.Database('./db/sample.db');

In the sample.db database, we create a table called langs for storing programming languages:
db.run('CREATE TABLE langs(name text)');
1
	
db.run('CREATE TABLE langs(name text)');

You can run the program to create the sample.db database and langs table as follows:
const sqlite3 = require('sqlite3').verbose();

let db = new sqlite3.Database('../db/sample.db');

db.run('CREATE TABLE langs(name text)');

db.close();
1
2
3
4
5
6
7
	
const sqlite3 = require('sqlite3').verbose();
 
let db = new sqlite3.Database('../db/sample.db');
 
db.run('CREATE TABLE langs(name text)');
 
db.close();

Now, we are ready to insert data into the langs table.
Insert one row into a table

To execute an INSERT statement, you use the run() method of the Database object:
db.run(sql, params, function(err){
  // 
});
1
2
3
	
db.run(sql, params, function(err){
  // 
});

The run() method executes an INSERT statement with specified parameters and calls a callback afterwards.

If an error occurred, you can find the detailed information in the err argument of the callback function.

In case the statement is executed successfully, the this object of the callback function will contain two properties:

    lastID property stores the value of the last inserted row ID.
    changes property stores the rows affected by the query.

The following insert.js program illustrates how to insert a row into the langs table:
  const sqlite3 = require('sqlite3').verbose();

  let db = new sqlite3.Database('./db/sample.db');

  // insert one row into the langs table
  db.run(`INSERT INTO langs(name) VALUES(?)`, ['C'], function(err) {
    if (err) {
      return console.log(err.message);
    }
    // get the last insert id
    console.log(`A row has been inserted with rowid ${this.lastID}`);
  });

  // close the database connection
  db.close();
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
	
  const sqlite3 = require('sqlite3').verbose();
 
  let db = new sqlite3.Database('./db/sample.db');
 
  // insert one row into the langs table
  db.run(`INSERT INTO langs(name) VALUES(?)`, ['C'], function(err) {
    if (err) {
      return console.log(err.message);
    }
    // get the last insert id
    console.log(`A row has been inserted with rowid ${this.lastID}`);
  });
 
  // close the database connection
  db.close();

Let’s run the insert.js program:
>node insert.js
A row has been inserted with rowid 1
1
2
	
>node insert.js
A row has been inserted with rowid 1

It worked as expected.
Insert multiple rows into a table at a time

To insert multiple rows at a time into a table, you use the following form of the INSERT statement:
INSERT INTO table_name(column_name)
VALUES(value_1), (value_2), (value_3),...
1
2
	
INSERT INTO table_name(column_name)
VALUES(value_1), (value_2), (value_3),...

To simulate this in the Node.js application, we first need to construct the INSERT statement with multiple placeholders:
INSERT INTO table_name(column_name)
VALUES(?), (?), (?),...
1
2
	
INSERT INTO table_name(column_name)
VALUES(?), (?), (?),...

Suppose, you want to insert rows into the langs table with the data from the following languages array:
let languages = ['C++', 'Python', 'Java', 'C#', 'Go'];
1
	
let languages = ['C++', 'Python', 'Java', 'C#', 'Go'];

To construct the INSERT statement, we use the map() method to map each element in the languages array into (?) and then join all placeholders together.
let placeholders = languages.map((language) => '(?)').join(',');
let sql = 'INSERT INTO langs(name) VALUES ' + placeholders;
1
2
	
let placeholders = languages.map((language) => '(?)').join(',');
let sql = 'INSERT INTO langs(name) VALUES ' + placeholders;

The following insert-many.js program illustrates how to insert multiple rows into the langs table:
const sqlite3 = require('sqlite3').verbose();

// open the database connection
let db = new sqlite3.Database('../db/sample.db');

let languages = ['C++', 'Python', 'Java', 'C#', 'Go'];

// construct the insert statement with multiple placeholders
// based on the number of rows
let placeholders = languages.map((language) => '(?)').join(',');
let sql = 'INSERT INTO langs(name) VALUES ' + placeholders;

// output the INSERT statement
console.log(sql);

db.run(sql, languages, function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Rows inserted ${this.changes}`);
});

// close the database connection
db.close();
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
	
const sqlite3 = require('sqlite3').verbose();
 
// open the database connection
let db = new sqlite3.Database('../db/sample.db');
 
let languages = ['C++', 'Python', 'Java', 'C#', 'Go'];
 
// construct the insert statement with multiple placeholders
// based on the number of rows
let placeholders = languages.map((language) => '(?)').join(',');
let sql = 'INSERT INTO langs(name) VALUES ' + placeholders;
 
// output the INSERT statement
console.log(sql);
 
db.run(sql, languages, function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Rows inserted ${this.changes}`);
});
 
// close the database connection
db.close();

Let’s run the insert-many.js program to see how it works.
> node insert-many.js
INSERT INTO langs(name) VALUES (?),(?),(?),(?),(?)
Rows inserted 5
1
2
3
	
> node insert-many.js
INSERT INTO langs(name) VALUES (?),(?),(?),(?),(?)
Rows inserted 5

It inserted 5 rows into the langs table which is what we expected.

In this tutorial, you have learned how to insert one or more rows into an SQLite table from a Node.js application.

Summary: this tutorial shows you how to update data in the SQLite database from a Node.js application.

To update data in the SQLite database from a Node.js application, you use these steps:

    Open a database connection.
    Execute an UPDATE statement.
    Close the database connection.

For the demonstration, we will use the langs table in the sample.db database that we created in the previous tutorial.
Updating data example

To update data in a table, you use the UPDATE statement as follows:
UPDATE table_name
SET column_name = value_1
WHERE id = id_value;
1
2
3
	
UPDATE table_name
SET column_name = value_1
WHERE id = id_value;

To execute the UPDATE statement in the Node.js application, you call the run() method of the Database object:
db.run(sql, params, function(err){
  // 
});
1
2
3
	
db.run(sql, params, function(err){
  // 
});

The run() method executes an UPDATE statement with specified parameters and calls a callback afterwards.

The err argument of the callback stores the error detail in case the execution has any problem e.g., syntax error, locking, etc.

If the UPDATE statement is executed successfully, the this object of the callback function will contain the changes property that stores the number of rows updated.

The following update.js program illustrates how to update a row in the langs table from C to Ansi C:
const sqlite3 = require('sqlite3').verbose();

// open a database connection
let db = new sqlite3.Database('./db/sample.db');

//
let data = ['Ansi C', 'C'];
let sql = `UPDATE langs
            SET name = ?
            WHERE name = ?`;

db.run(sql, data, function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Row(s) updated: ${this.changes}`);

});

// close the database connection
db.close();
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
	
const sqlite3 = require('sqlite3').verbose();
 
// open a database connection
let db = new sqlite3.Database('./db/sample.db');
 
//
let data = ['Ansi C', 'C'];
let sql = `UPDATE langs
            SET name = ?
            WHERE name = ?`;
 
db.run(sql, data, function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Row(s) updated: ${this.changes}`);
 
});
 
// close the database connection
db.close();

Let’s test the update.js program.
>node update.js
Row(s) updated: 1
1
2
	
>node update.js
Row(s) updated: 1

The output showed that one row has been updated which is correct.

In this tutorial, you have learned how to update data in the SQLite database from a Node.js application.

To delete data in the SQLite database from a Node.js application, you use the following steps:

    Open a database connection.
    Execute a DELETE statement.
    Close the database connection.

For the demonstration, we will use the langs table in the sample.db database that we created in the previous tutorial.
Deleting data example

To delete data from a table, you use the DELETE statement as follows:
DELETE FROM table_name
WHERE column_name = value;
1
2
	
DELETE FROM table_name
WHERE column_name = value;

To execute the DELETE statement from a Node.js application, you call the run() method of the Database object as follows:
db.run(sql, params, function(err) {
  // 
});
1
2
3
	
db.run(sql, params, function(err) {
  // 
});

The run() method allows you to execute a DELETE statement with specified parameters and calls a callback function afterwards.

If there was any error during the execution of DELETE statement, the err argument of the callback function will provide the detail. In case the DELETE statement executed successfully, the this object of the callback function will contain the changes property that stores the number of rows deleted.

The following delete.js program illustrates how to delete a row from the langs table:
const sqlite3 = require('sqlite3').verbose();

// open a database connection
let db = new sqlite3.Database('./db/sample.db', (err) => {
  if (err) {
    console.error(err.message);
  }
});

let id = 1;
// delete a row based on id
db.run(`DELETE FROM langs WHERE rowid=?`, id, function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Row(s) deleted ${this.changes}`);
});

// close the database connection
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
});
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
	
const sqlite3 = require('sqlite3').verbose();
 
// open a database connection
let db = new sqlite3.Database('./db/sample.db', (err) => {
  if (err) {
    console.error(err.message);
  }
});
 
let id = 1;
// delete a row based on id
db.run(`DELETE FROM langs WHERE rowid=?`, id, function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Row(s) deleted ${this.changes}`);
});
 
// close the database connection
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
});

Let’s test the update.js program.
>node delete.js
Row(s) deleted: 1
1
2
	
>node delete.js
Row(s) deleted: 1

The output showed that one row has been deleted successfully.

In this tutorial, you have learned how to delete data in the SQLite database from a Node.js application.


var sqlite3 = require('sqlite3').verbose();
var db = new sqlite3.Database('mydb.db');
var check;
db.serialize(function() {

  db.run("CREATE TABLE if not exists user_info (info TEXT)");
  var stmt = db.prepare("INSERT INTO user_info VALUES (?)");
  for (var i = 0; i < 10; i++) {
      stmt.run("Ipsum " + i);
  }
  stmt.finalize();

  db.each("SELECT rowid AS id, info FROM user_info", function(err, row) {
      console.log(row.id + ": " + row.info);
  });
});

db.close();

To perform SELECT query you should use .all function and for other operations such as DELETE, UPDATE, INSERT you should use .run function. Here have a look to simple code.
//Load modules
var sqlite3         =       require('sqlite3').verbose();
var db              =       new sqlite3.Database('./database_name.db');

//Perform SELECT Operation
db.all("SELECT * from blah blah blah where this="+that,function(err,rows){
//rows contain values while errors, well you can figure out.
});

//Perform INSERT operation.
db.run("INSERT into table_name(col1,col2,col3) VALUES (val1,val2,val3)");

//Perform DELETE operation
db.run("DELETE * from table_name where condition");

//Perform UPDATE operation
db.run("UPDATE table_name where condition");


function debounce(fn, delay) {
  let timer = null;
  return function () {
    var context = this, args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(context, args);
    }, delay);
  };
};

document.addEventListener("selectionchange", debounce(function (event) {
  let selection = document.getSelection ? document.getSelection().toString() :  document.selection.createRange().toString() ;
  console.log(selection);
}, 250));



function setupInputElement() {

  var inputElement = document.querySelector('#fname');

  inputElement.addEventListener('change', function (e) {
	console.log("value is " + inputElement.value);
	console.log(inputElement.files[0].path);
        var file = e.target.files[0];
		url = file;
        if (window.FileReader) {
            var reader = new FileReader();
            reader.onload = openBook;
            reader.readAsArrayBuffer(file);
        }
    });
}

function openBook(e) {
	console.log("openBook function");
    var bookData = e.target.result;
    var title = document.getElementById("title");
    var next = document.getElementById("next");
    var prev = document.getElementById("prev");
	var currentSectionIndex = 0;
    book.open(bookData, "binary");

    rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600
    });

    rendition.display(currentSectionIndex);
	
	book.ready.then(() => {

      var next = document.getElementById("next");
		console.log(book.package.metadata.direction);
      next.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        e.preventDefault();
      }, false);

      var prev = document.getElementById("prev");
      prev.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        e.preventDefault();
      }, false);

      var keyListener = function(e){

        // Left Key
        if ((e.keyCode || e.which) == 37) {
          book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        }

        // Right Key
        if ((e.keyCode || e.which) == 39) {
          book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        }

      };

      rendition.on("keyup", keyListener);
      document.addEventListener("keyup", keyListener, false);

    })

    var title = document.getElementById("title");

    rendition.on("rendered", function(section){
	console.log("rendered");
      var current = book.navigation && book.navigation.get(section.href);
		console.log("current is " + current);
      if (current) {
        var $select = document.getElementById("toc");
		console.log("select is " + $select);
        var $selected = $select.querySelector("option[selected]");
        if ($selected) {
          $selected.removeAttribute("selected");
        }

        var $options = $select.querySelectorAll("option");
        for (var i = 0; i < $options.length; ++i) {
          let selected = $options[i].getAttribute("ref") === current.href;
          if (selected) {
            $options[i].setAttribute("selected", "");
          }
        }
      }

    });

    rendition.on("relocated", function(location){
      console.log(location);

      var next = book.package.metadata.direction === "rtl" ?  document.getElementById("prev") : document.getElementById("next");
      var prev = book.package.metadata.direction === "rtl" ?  document.getElementById("next") : document.getElementById("prev");

      if (location.atEnd) {
        next.style.visibility = "hidden";
      } else {
        next.style.visibility = "visible";
      }

      if (location.atStart) {
	  console.log("at start");
        prev.style.visibility = "hidden";
      } else {
        prev.style.visibility = "visible";
      }

    });

    rendition.on("layout", function(layout) {
      let viewer = document.getElementById("viewer");

      if (layout.spread) {
        viewer.classList.remove('single');
      } else {
        viewer.classList.add('single');
      }
    });

    window.addEventListener("unload", function () {
      console.log("unloading");
      this.book.destroy();
    });

    book.loaded.navigation.then(function(toc){
		console.log("setting up toc");
			var $select = document.getElementById("toc"),
					docfrag = document.createDocumentFragment();

			toc.forEach(function(chapter) {
				var option = document.createElement("option");
				option.textContent = chapter.label;
				option.setAttribute("ref", chapter.href);

				docfrag.appendChild(option);
			});

			$select.appendChild(docfrag);

			$select.onchange = function(){
					var index = $select.selectedIndex,
							url = $select.options[index].getAttribute("ref");
					rendition.display(url);
					return false;
			};

		});
}

whenever I increase the font-size by calling rendition.themes.fontSize("140%") the book location changes - text from the previous pages is shown. The opposite happens when decreasing font-size. Is there a way to lock the view to a certain CFI? Wondering what the best practice would be here.

book.loaded.metadata
var currentLocation = rendition.currentLocation();

And after that an explanation of currentLocation.start.cfi and currentLocation.end.cfi

var cfi = Rendition.currentLocation().start.cfi;
var TOCIndex = Book.spine.get(cfi).index;

//current output is like cfi = epubcfi(/6/6[chapter1.1]!/4/2/2/1:0) and TOCIndex = 2

//needed output should be cfi = epubcfi(/6/6[chapter1.1]!/4/2/2/1:0) and TOCIndex = 1

while i debugging it i found that CFI is good but index is wrong

I save the Cfi to localstorage by "renderer:locationChanged" event, like this:

Book.on('renderer:locationChanged', function(location) {
obj.lastRead = location;
localStorage["{{$story->id}}-{{$body->chapter}}"] = JSON.stringify(obj);
});

And use "lastRead" to return the page, like:

var obj = JSON.parse(window.localStorage["{{$story->id}}-{{$body->chapter}}"]);
if(obj.lastRead != 0) {
Book.gotoCfi(obj.lastRead);
}

But I just can return to previous page, for instance, if I stay in Page 5 and refresh the page, it will return to Page 4, how can I return the correct page when I refresh the page?

https://github.com/futurepress/epub.js/issues/571
Moby Dick demo doesn't work with Chrome translator extension #571 - t emporary solution

What I've done is simply using book.locations.generate() to get the total number of characters in a book. The time is calculated as

// the percentage of the book left
// `1` will calculate the estimated time for the whole book
percentage 

* book.locations.total

// the `chars` argument passed to `locations.generate`
* CHARACTERS_PER_PAGE

// roughly 6 for English; I've used 2.5 for CJK languages
/ CHARACTERS_PER_WORD

// roughly 200
/ WORDS_PER_MINUTE

It's a very rough estimate, but from my testing the results are similar to those given by Medium and other platforms.

rendition.on('relocated', function(location){
console.log(location.start.index);
});

https://github.com/futurepress/epub.js/blob/master/examples/themes.html change font size


App.prototype.onRenditionRelocatedUpdateIndicators = function (event) {
    try {
        if (this.getChipActive("progress") == "bar") {
            // TODO: don't recreate every time the location changes.
            this.qs(".bar .loc").innerHTML = "";
            
            let bar = this.qs(".bar .loc").appendChild(document.createElement("div"));
            bar.style.position = "relative";
            bar.style.width = "60vw";
            bar.style.cursor = "default";
            bar.addEventListener("click", ev => ev.stopImmediatePropagation(), false);

            let range = bar.appendChild(document.createElement("input"));
            range.type = "range";
            range.style.width = "100%";
            range.min = 0;
            range.max = this.state.book.locations.length();
            range.value = event.start.location;
            range.addEventListener("change", () => this.state.rendition.display(this.state.book.locations.cfiFromLocation(range.value)), false);

            let markers = bar.appendChild(document.createElement("div"));
            markers.style.position = "absolute";
            markers.style.width = "100%";
            markers.style.height = "50%";
            markers.style.bottom = "0";
            markers.style.left = "0";
            markers.style.right = "0";

            for (let i = 0, last = -1; i < this.state.book.locations.length(); i++) {
                try {
                    let parsed = new ePub.CFI().parse(this.state.book.locations.cfiFromLocation(i));
                    if (parsed.spinePos < 0 || parsed.spinePos == last)
                        continue;
                    last = parsed.spinePos;

                    let marker = markers.appendChild(document.createElement("div"));
                    marker.style.position = "absolute";
                    marker.style.left = `${this.state.book.locations.percentageFromLocation(i) * 100}%`;
                    marker.style.width = "4px";
                    marker.style.height = "30%";
                    marker.style.cursor = "pointer";
                    marker.style.opacity = "0.5";
                    marker.addEventListener("click", this.onTocItemClick.bind(this, this.state.book.locations.cfiFromLocation(i)), false);

                    let tick = marker.appendChild(document.createElement("div"));
                    tick.style.width = "1px";
                    tick.style.height = "100%";
                    tick.style.backgroundColor = "currentColor";
                } catch (ex) {
                    console.warn("Error adding marker for location", i, ex);
                }
            }

            return;
        }

        let stxt = "Loading";
        if (this.getChipActive("progress") == "none") {
            stxt = "";
        } else if (this.getChipActive("progress") == "location" && event.start.location > 0) {
            stxt = `Loc ${event.start.location}/${this.state.book.locations.length()}`
        } else if (this.getChipActive("progress") == "chapter") {
            let navItem = this.getNavItem(event, false) || this.getNavItem(event, true);
            stxt = navItem ? navItem.label.trim() : (event.start.percentage > 0 && event.start.percentage < 1) ? `${Math.round(event.start.percentage * 100)}%` : "";
        } else {
            stxt = (event.start.percentage > 0 && event.start.percentage < 1) ? `${Math.round(event.start.percentage * 1000)/10}%` : "";
        }
        this.qs(".bar .loc").innerHTML = stxt;
    } catch (err) {
        console.error("error updating indicators");
    }
};

App.prototype.onBookMetadataLoaded = function (metadata) {
    console.log("metadata", metadata);
    this.qs(".bar .book-title").innerText = metadata.title.trim();
    this.qs(".bar .book-author").innerText = metadata.creator.trim();
    this.qs(".info .title").innerText = metadata.title.trim();
    this.qs(".info .author").innerText = metadata.creator.trim();
    if (!metadata.series || metadata.series.trim() == "") this.qs(".info .series-info").classList.add("hidden");
    this.qs(".info .series-name").innerText = metadata.series.trim();
    this.qs(".info .series-index").innerText = metadata.seriesIndex.trim();
    this.qs(".info .description").innerText = metadata.description;
    if (sanitizeHtml) this.qs(".info .description").innerHTML = sanitizeHtml(metadata.description);
};

